# 贪吃蛇项目开发中遇到的问题

## 1. 输入系统卡顿、按键丢失和 UI 响应延迟问题

### 问题描述

**游戏场景：** 方向键响应不跟手，快速按键时部分输入被忽略。  
**菜单/游戏结束场景：** 鼠标移动卡顿，点击延迟数秒才响应，甚至看起来像"死机"。

### 问题原因

**1. 输入检测频率过低（游戏场景）**

- 方向键检测绑定在游戏逻辑更新上（10 FPS，100ms 间隔）
- `GetAsyncKeyState` 返回调用瞬间的按键状态
- 玩家在两次检测之间快速按下并松开，输入会完全丢失

**2. 防抖逻辑 Bug（所有场景）**

```cpp
// ❌ 错误写法
if (GetAsyncKeyState(VK_SPACE) & 0x8000) {
    static bool spacePressed = false;  // if 作用域
    if (!spacePressed) { TogglePause(); spacePressed = true; }
}
else {
    static bool spacePressed = false;  // else 作用域，是不同的变量！
    spacePressed = false;
}
```

- `static` 变量在不同作用域重复声明，实际是两个独立变量
- 导致防抖失效，按键连发

**3. 鼠标消息队列积压（菜单/游戏结束场景）**

```cpp
// ❌ 错误写法
while (menuRunning) {
    if (MouseHit()) {  // 每次只处理一个消息
        MOUSEMSG msg = GetMouseMsg();
        // 处理消息...
    }
    Render();
    Sleep(50);  // 20 FPS
}
```

- **问题链条：**
  1. 菜单刷新率 20 FPS（每 50ms 处理一次）
  2. 鼠标移动产生消息的频率远高于此（~100+ FPS）
  3. `if (MouseHit())` 每帧只处理一个消息
  4. 消息队列迅速积压，导致：
     - 鼠标移动延迟数秒才显示
     - 点击事件被积压的 `WM_MOUSEMOVE` 淹没
     - 程序看起来像"卡死"

**4. 渲染浪费 CPU 资源**

- 每 10ms 渲染一次，但游戏状态 100ms 才更新一次
- 90% 的渲染是重复绘制

**5. 输入状态管理混乱（所有场景）**

- 菜单用成员变量防抖
- 游戏用 `static` 变量防抖
- 游戏结束用 `static` 变量防抖
- 三套独立系统，维护困难，容易出错

### 解决方案

**1. 实现输入缓冲系统**

```cpp
// KeyboardController 中添加
Direction bufferedInput;   // 缓存输入
bool hasBufferedInput;
bool keyState[4];          // 用于边沿检测

void CacheInput() {
    // 高频采样（~1000 FPS），边沿触发
    if (IsKeyPressed(keyUp) && !keyState[0]) {
        bufferedInput = UP;
        hasBufferedInput = true;
    }
    keyState[0] = IsKeyPressed(keyUp);
}

Direction MakeDecision(...) {
    // 低频消费（10 FPS）
    if (hasBufferedInput) {
        Direction result = bufferedInput;
        hasBufferedInput = false;
        return result;
    }
}
```

**2. 修复防抖逻辑**

```cpp
// ✅ 正确写法
void HandleInput() {
    static bool spaceWasPressed = false;  // 函数作用域声明一次
    bool spaceIsPressed = (GetAsyncKeyState(VK_SPACE) & 0x8000) != 0;

    if (spaceIsPressed && !spaceWasPressed) {  // 边沿触发
        TogglePause();
    }
    spaceWasPressed = spaceIsPressed;
}
```

**3. 分层频率架构**

```cpp
while (isRunning) {
    // UI输入检测 (~1000 FPS)
    HandleInput();
    CacheGameInput();  // 方向键采样

    // 游戏逻辑更新 (10 FPS)
    if (currentTime - lastUpdateTime >= 100ms) {
        Update();  // 消费缓冲的输入
    }

    // 渲染更新 (60 FPS)
    if (currentTime - lastRenderTime >= 16ms) {
        Render();
    }

    Sleep(1);
}
```

### 优化效果

| 指标           | 优化前   | 优化后    |
| -------------- | -------- | --------- |
| 方向键响应频率 | 10 FPS   | ~1000 FPS |
| 最大输入延迟   | 100ms    | 1ms       |
| 输入丢失       | 经常丢失 | 基本不丢  |

---

## 2. 窗口生命周期管理混乱导致游戏结束后 GUI 崩溃

### 问题描述

**现象：** 游戏结束点击"返回菜单"后，GUI 窗口崩溃消失，只剩下 CMD 控制台窗口，但程序未报错。

### 问题原因

**1. 多处窗口管理导致冲突**

```cpp
// MenuScene 析构
MenuScene::~MenuScene() {
    closegraph();  // 第一次关闭窗口
}

// Renderer 析构
Renderer::~Renderer() {
    closegraph();  // 第二次关闭窗口！
}

// main 函数
int main() {
    MenuScene menu;
    GameMode mode = menu.Show();  // 退出时 menu 析构 -> closegraph()

    GameManager game;
    game.Init(mode);              // 创建 Renderer -> initgraph()
    game.Run();                   // 游戏运行

    return 0;                     // game 析构 -> Renderer 析构 -> closegraph()
}
```

**问题链条：**

1. 用户点击"返回菜单" → `GameManager::GameOver()` 设置 `isRunning = false`
2. 主循环退出 → `main()` 函数返回
3. `game` 对象析构 → `Renderer` 析构 → 调用 `closegraph()`
4. 窗口被关闭，但此时还在主函数中
5. 如果有任何后续代码尝试访问窗口资源 → 崩溃

**2. 缺少菜单循环**

```cpp
// ❌ 原来的 main
int main() {
    MenuScene menu;
    GameMode mode = menu.Show();

    GameManager game;
    game.Init(mode);
    game.Run();

    return 0;  // 游戏结束就直接退出，没有回到菜单
}
```

- 用户期望：游戏结束 → 返回菜单 → 可以再次游玩
- 实际行为：游戏结束 → 程序退出
- "返回菜单"按钮实际上是"退出程序"

**3. 资源所有权不清晰**

- `MenuScene` 创建窗口，也关闭窗口
- `Renderer` 创建窗口，也关闭窗口
- 每个对象都认为自己拥有窗口的所有权
- 导致重复创建、重复关闭、生命周期混乱

### 解决方案

采用**方案 C：统一窗口管理，分离窗口生命周期**

#### **1. 主函数统一管理窗口**

```cpp
int main() {
    // 创建全局窗口（只创建一次）
    int maxWidth = MAP_WIDTH * BLOCK_SIZE + 200;
    int maxHeight = MAP_HEIGHT * BLOCK_SIZE;
    initgraph(maxWidth, maxHeight);
    SetWindowText(GetHWnd(), L"贪吃蛇游戏");

    // 主循环：菜单 -> 游戏 -> 菜单
    while (true) {
        MenuScene menu(false);  // 不管理窗口
        GameMode mode = menu.Show();

        if (mode == EXIT) break;  // 用户选择退出

        GameManager game;
        game.Init(mode);
        game.Run();

        cleardevice();  // 清空画面准备下一次循环
    }

    // 关闭全局窗口（只关闭一次）
    closegraph();
    return 0;
}
```

#### **2. MenuScene 不再管理窗口**

```cpp
class MenuScene {
private:
    bool manageWindow;  // 是否管理窗口生命周期

public:
    MenuScene(bool manageWindow = false);
    ~MenuScene();
};

MenuScene::MenuScene(bool manageWindow)
    : manageWindow(manageWindow) { }

MenuScene::~MenuScene() {
    // 只有当 MenuScene 管理窗口时才关闭
    if (manageWindow) {
        closegraph();
    }
}

GameMode MenuScene::Show() {
    // 只有当管理窗口时才创建
    if (manageWindow) {
        initgraph(800, 600);
    }

    setbkcolor(RGB(20, 20, 40));
    cleardevice();

    // 菜单逻辑...

    // 只有当管理窗口时才关闭
    if (manageWindow) {
        closegraph();
    }

    return selectedMode;
}
```

#### **3. Renderer 不再管理窗口**

```cpp
class Renderer {
private:
    bool ownsWindow;  // 是否拥有窗口所有权

public:
    bool Init(int width, int height, const wchar_t *title,
              bool createWindow = false);
    void Close();
};

bool Renderer::Init(int width, int height, const wchar_t *title,
                    bool createWindow) {
    ownsWindow = createWindow;

    if (createWindow) {
        initgraph(width, height);
    }

    // 设置窗口属性（不创建窗口）
    HWND hwnd = GetHWnd();
    if (hwnd) {
        SetWindowText(hwnd, title);
    }

    // 初始化渲染状态...
}

void Renderer::Close() {
    if (initialized && ownsWindow) {
        closegraph();  // 只有拥有所有权时才关闭
    }
}
```

#### **4. GameManager 传递 createWindow=false**

```cpp
void GameManager::InitSingleMode() {
    renderer = new Renderer();
    int totalWidth = MAP_WIDTH * BLOCK_SIZE + 200;
    renderer->Init(totalWidth, MAP_HEIGHT * BLOCK_SIZE,
                   L"贪吃蛇游戏", false);  // 不创建窗口
    // ...
}
```

#### **5. 添加 EXIT 枚举支持退出**

```cpp
enum GameMode {
    BEGINNER, ADVANCED, EXPERT,
    SINGLE, LOCAL_PVP, NET_PVP, PVE,
    EXIT  // 新增：退出游戏
};

// 主菜单中的"退出游戏"选项返回 EXIT
MenuItem item3;
item3.text = L"退出游戏";
item3.mode = EXIT;  // 返回 EXIT 模式
```

### 优化效果

| 对比维度     | 优化前（方案 A）       | 优化后（方案 C）     |
| ------------ | ---------------------- | -------------------- |
| 窗口创建次数 | 每次菜单/游戏都创建    | 只创建一次           |
| 窗口闪烁     | 有明显闪烁             | 无闪烁               |
| 资源管理     | 混乱，多处 closegraph  | 清晰，统一管理       |
| 返回菜单     | 不支持                 | 支持循环游玩         |
| 崩溃问题     | 游戏结束后 GUI 崩溃    | 完全修复             |
| 代码复杂度   | 简单                   | 需要参数控制所有权   |
| 性能         | 每次重建窗口（~100ms） | 无重建开销           |
| 用户体验     | 每次游玩需重启程序     | 流畅切换菜单和游戏   |
| 单一职责原则 | 违反（多处管理窗口）   | 符合（主函数统一管） |

### 设计原则

**1. 单一职责原则**

- 主函数：负责窗口生命周期
- MenuScene：负责菜单逻辑
- Renderer：负责渲染逻辑
- GameManager：负责游戏逻辑

**2. 所有权明确**

- `manageWindow` / `ownsWindow` 标志明确表示所有权
- 只有拥有所有权的对象才能创建/销毁资源
- 避免重复释放和悬空指针

**3. 资源获取即初始化（RAII）的适配**

- 虽然窗口由主函数管理（非 RAII）
- 但每个游戏对象仍然遵循 RAII 自动析构
- 平衡了全局资源管理和对象生命周期管理

---

## 3. 高 DPI 屏幕下画面模糊和文字锯齿问题

### 问题描述

在 Windows 缩放设置为 125%/150% 的高分辨率屏幕上，游戏画面整体模糊不清，文字边缘有明显锯齿感。

### 问题原因

**1. DPI 缩放导致画面拉伸**

- Windows 自动将程序窗口拉伸以适应缩放比例
- EasyX 绘制的像素被强行放大，导致整体模糊
- 类似低分辨率图片放大的效果

**2. 文字未启用抗锯齿**

- EasyX 默认使用 GDI 绘制文字，未开启 ClearType
- 小字号文字边缘锯齿明显
- 在高 DPI 屏幕上效果尤其差

### 解决方案

**1. 启用高 DPI 感知**

```cpp
// main.cpp - 在 initgraph 之前调用
SetProcessDPIAware();
```

告诉 Windows 程序能自行处理高分辨率，不要自动缩放。

**2. 启用 ClearType 文字抗锯齿**

```cpp
// Renderer::Init() 中设置
LOGFONT f;
gettextstyle(&f);
f.lfQuality = CLEARTYPE_QUALITY;  // 开启 ClearType
wcscpy_s(f.lfFaceName, L"微软雅黑");
settextstyle(&f);
```

### 优化效果

| 指标       | 优化前           | 优化后       |
| ---------- | ---------------- | ------------ |
| 画面清晰度 | 125% 缩放时模糊  | 1:1 像素清晰 |
| 文字边缘   | 明显锯齿         | 平滑抗锯齿   |
| 用户体验   | 看起来像低分辨率 | 高清显示     |

---

_最后更新：2025 年 12 月 6 日_
