# 贪吃蛇项目开发中遇到的问题

## 1. 输入系统卡顿、按键丢失和 UI 响应延迟问题

### 问题描述

**游戏场景：** 方向键响应不跟手，快速按键时部分输入被忽略。  
**菜单/游戏结束场景：** 鼠标移动卡顿，点击延迟数秒才响应，甚至看起来像"死机"。

### 问题原因

**1. 输入检测频率过低（游戏场景）**

- 方向键检测绑定在游戏逻辑更新上（10 FPS，100ms 间隔）
- `GetAsyncKeyState` 返回调用瞬间的按键状态
- 玩家在两次检测之间快速按下并松开，输入会完全丢失

**2. 防抖逻辑 Bug（所有场景）**

```cpp
// ❌ 错误写法
if (GetAsyncKeyState(VK_SPACE) & 0x8000) {
    static bool spacePressed = false;  // if 作用域
    if (!spacePressed) { TogglePause(); spacePressed = true; }
}
else {
    static bool spacePressed = false;  // else 作用域，是不同的变量！
    spacePressed = false;
}
```

- `static` 变量在不同作用域重复声明，实际是两个独立变量
- 导致防抖失效，按键连发

**3. 鼠标消息队列积压（菜单/游戏结束场景）**

```cpp
// ❌ 错误写法
while (menuRunning) {
    if (MouseHit()) {  // 每次只处理一个消息
        MOUSEMSG msg = GetMouseMsg();
        // 处理消息...
    }
    Render();
    Sleep(50);  // 20 FPS
}
```

- **问题链条：**
  1. 菜单刷新率 20 FPS（每 50ms 处理一次）
  2. 鼠标移动产生消息的频率远高于此（~100+ FPS）
  3. `if (MouseHit())` 每帧只处理一个消息
  4. 消息队列迅速积压，导致：
     - 鼠标移动延迟数秒才显示
     - 点击事件被积压的 `WM_MOUSEMOVE` 淹没
     - 程序看起来像"卡死"

**4. 渲染浪费 CPU 资源**

- 每 10ms 渲染一次，但游戏状态 100ms 才更新一次
- 90% 的渲染是重复绘制

**5. 输入状态管理混乱（所有场景）**

- 菜单用成员变量防抖
- 游戏用 `static` 变量防抖
- 游戏结束用 `static` 变量防抖
- 三套独立系统，维护困难，容易出错

### 解决方案

**1. 实现输入缓冲系统**

```cpp
// KeyboardController 中添加
Direction bufferedInput;   // 缓存输入
bool hasBufferedInput;
bool keyState[4];          // 用于边沿检测

void CacheInput() {
    // 高频采样（~1000 FPS），边沿触发
    if (IsKeyPressed(keyUp) && !keyState[0]) {
        bufferedInput = UP;
        hasBufferedInput = true;
    }
    keyState[0] = IsKeyPressed(keyUp);
}

Direction MakeDecision(...) {
    // 低频消费（10 FPS）
    if (hasBufferedInput) {
        Direction result = bufferedInput;
        hasBufferedInput = false;
        return result;
    }
}
```

**2. 修复防抖逻辑**

```cpp
// ✅ 正确写法
void HandleInput() {
    static bool spaceWasPressed = false;  // 函数作用域声明一次
    bool spaceIsPressed = (GetAsyncKeyState(VK_SPACE) & 0x8000) != 0;

    if (spaceIsPressed && !spaceWasPressed) {  // 边沿触发
        TogglePause();
    }
    spaceWasPressed = spaceIsPressed;
}
```

**3. 分层频率架构**

```cpp
while (isRunning) {
    // UI输入检测 (~1000 FPS)
    HandleInput();
    CacheGameInput();  // 方向键采样

    // 游戏逻辑更新 (10 FPS)
    if (currentTime - lastUpdateTime >= 100ms) {
        Update();  // 消费缓冲的输入
    }

    // 渲染更新 (60 FPS)
    if (currentTime - lastRenderTime >= 16ms) {
        Render();
    }

    Sleep(1);
}
```

### 优化效果

| 指标           | 优化前   | 优化后    |
| -------------- | -------- | --------- |
| 方向键响应频率 | 10 FPS   | ~1000 FPS |
| 最大输入延迟   | 100ms    | 1ms       |
| 输入丢失       | 经常丢失 | 基本不丢  |

---

## 2. 窗口生命周期管理混乱导致游戏结束后 GUI 崩溃

### 问题描述

**现象：** 游戏结束点击"返回菜单"后，GUI 窗口崩溃消失，只剩下 CMD 控制台窗口，但程序未报错。

### 问题原因

**1. 多处窗口管理导致冲突**

```cpp
// MenuScene 析构
MenuScene::~MenuScene() {
    closegraph();  // 第一次关闭窗口
}

// Renderer 析构
Renderer::~Renderer() {
    closegraph();  // 第二次关闭窗口！
}

// main 函数
int main() {
    MenuScene menu;
    GameMode mode = menu.Show();  // 退出时 menu 析构 -> closegraph()

    GameManager game;
    game.Init(mode);              // 创建 Renderer -> initgraph()
    game.Run();                   // 游戏运行

    return 0;                     // game 析构 -> Renderer 析构 -> closegraph()
}
```

**问题链条：**

1. 用户点击"返回菜单" → `GameManager::GameOver()` 设置 `isRunning = false`
2. 主循环退出 → `main()` 函数返回
3. `game` 对象析构 → `Renderer` 析构 → 调用 `closegraph()`
4. 窗口被关闭，但此时还在主函数中
5. 如果有任何后续代码尝试访问窗口资源 → 崩溃

**2. 缺少菜单循环**

```cpp
// ❌ 原来的 main
int main() {
    MenuScene menu;
    GameMode mode = menu.Show();

    GameManager game;
    game.Init(mode);
    game.Run();

    return 0;  // 游戏结束就直接退出，没有回到菜单
}
```

- 用户期望：游戏结束 → 返回菜单 → 可以再次游玩
- 实际行为：游戏结束 → 程序退出
- "返回菜单"按钮实际上是"退出程序"

**3. 资源所有权不清晰**

- `MenuScene` 创建窗口，也关闭窗口
- `Renderer` 创建窗口，也关闭窗口
- 每个对象都认为自己拥有窗口的所有权
- 导致重复创建、重复关闭、生命周期混乱

### 解决方案

采用**方案 C：统一窗口管理，分离窗口生命周期**

#### **1. 主函数统一管理窗口**

```cpp
int main() {
    // 创建全局窗口（只创建一次）
    int maxWidth = MAP_WIDTH * BLOCK_SIZE + 200;
    int maxHeight = MAP_HEIGHT * BLOCK_SIZE;
    initgraph(maxWidth, maxHeight);
    SetWindowText(GetHWnd(), L"贪吃蛇游戏");

    // 主循环：菜单 -> 游戏 -> 菜单
    while (true) {
        MenuScene menu(false);  // 不管理窗口
        GameMode mode = menu.Show();

        if (mode == EXIT) break;  // 用户选择退出

        GameManager game;
        game.Init(mode);
        game.Run();

        cleardevice();  // 清空画面准备下一次循环
    }

    // 关闭全局窗口（只关闭一次）
    closegraph();
    return 0;
}
```

#### **2. MenuScene 不再管理窗口**

```cpp
class MenuScene {
private:
    bool manageWindow;  // 是否管理窗口生命周期

public:
    MenuScene(bool manageWindow = false);
    ~MenuScene();
};

MenuScene::MenuScene(bool manageWindow)
    : manageWindow(manageWindow) { }

MenuScene::~MenuScene() {
    // 只有当 MenuScene 管理窗口时才关闭
    if (manageWindow) {
        closegraph();
    }
}

GameMode MenuScene::Show() {
    // 只有当管理窗口时才创建
    if (manageWindow) {
        initgraph(800, 600);
    }

    setbkcolor(RGB(20, 20, 40));
    cleardevice();

    // 菜单逻辑...

    // 只有当管理窗口时才关闭
    if (manageWindow) {
        closegraph();
    }

    return selectedMode;
}
```

#### **3. Renderer 不再管理窗口**

```cpp
class Renderer {
private:
    bool ownsWindow;  // 是否拥有窗口所有权

public:
    bool Init(int width, int height, const wchar_t *title,
              bool createWindow = false);
    void Close();
};

bool Renderer::Init(int width, int height, const wchar_t *title,
                    bool createWindow) {
    ownsWindow = createWindow;

    if (createWindow) {
        initgraph(width, height);
    }

    // 设置窗口属性（不创建窗口）
    HWND hwnd = GetHWnd();
    if (hwnd) {
        SetWindowText(hwnd, title);
    }

    // 初始化渲染状态...
}

void Renderer::Close() {
    if (initialized && ownsWindow) {
        closegraph();  // 只有拥有所有权时才关闭
    }
}
```

#### **4. GameManager 传递 createWindow=false**

```cpp
void GameManager::InitSingleMode() {
    renderer = new Renderer();
    int totalWidth = MAP_WIDTH * BLOCK_SIZE + 200;
    renderer->Init(totalWidth, MAP_HEIGHT * BLOCK_SIZE,
                   L"贪吃蛇游戏", false);  // 不创建窗口
    // ...
}
```

#### **5. 添加 EXIT 枚举支持退出**

```cpp
enum GameMode {
    BEGINNER, ADVANCED, EXPERT,
    SINGLE, LOCAL_PVP, NET_PVP, PVE,
    EXIT  // 新增：退出游戏
};

// 主菜单中的"退出游戏"选项返回 EXIT
MenuItem item3;
item3.text = L"退出游戏";
item3.mode = EXIT;  // 返回 EXIT 模式
```

### 优化效果

| 对比维度     | 优化前（方案 A）       | 优化后（方案 C）     |
| ------------ | ---------------------- | -------------------- |
| 窗口创建次数 | 每次菜单/游戏都创建    | 只创建一次           |
| 窗口闪烁     | 有明显闪烁             | 无闪烁               |
| 资源管理     | 混乱，多处 closegraph  | 清晰，统一管理       |
| 返回菜单     | 不支持                 | 支持循环游玩         |
| 崩溃问题     | 游戏结束后 GUI 崩溃    | 完全修复             |
| 代码复杂度   | 简单                   | 需要参数控制所有权   |
| 性能         | 每次重建窗口（~100ms） | 无重建开销           |
| 用户体验     | 每次游玩需重启程序     | 流畅切换菜单和游戏   |
| 单一职责原则 | 违反（多处管理窗口）   | 符合（主函数统一管） |

### 设计原则

**1. 单一职责原则**

- 主函数：负责窗口生命周期
- MenuScene：负责菜单逻辑
- Renderer：负责渲染逻辑
- GameManager：负责游戏逻辑

**2. 所有权明确**

- `manageWindow` / `ownsWindow` 标志明确表示所有权
- 只有拥有所有权的对象才能创建/销毁资源
- 避免重复释放和悬空指针

**3. 资源获取即初始化（RAII）的适配**

- 虽然窗口由主函数管理（非 RAII）
- 但每个游戏对象仍然遵循 RAII 自动析构
- 平衡了全局资源管理和对象生命周期管理

---

## 3. 高 DPI 屏幕下画面模糊和文字锯齿问题

### 问题描述

在 Windows 缩放设置为 125%/150% 的高分辨率屏幕上，游戏画面整体模糊不清，文字边缘有明显锯齿感。

### 问题原因

**1. DPI 缩放导致画面拉伸**

- Windows 自动将程序窗口拉伸以适应缩放比例
- EasyX 绘制的像素被强行放大，导致整体模糊
- 类似低分辨率图片放大的效果

**2. 文字未启用抗锯齿**

- EasyX 默认使用 GDI 绘制文字，未开启 ClearType
- 小字号文字边缘锯齿明显
- 在高 DPI 屏幕上效果尤其差

### 解决方案

**1. 启用高 DPI 感知**

```cpp
// main.cpp - 在 initgraph 之前调用
SetProcessDPIAware();
```

告诉 Windows 程序能自行处理高分辨率，不要自动缩放。

**2. 启用 ClearType 文字抗锯齿**

```cpp
// Renderer::Init() 中设置
LOGFONT f;
gettextstyle(&f);
f.lfQuality = CLEARTYPE_QUALITY;  // 开启 ClearType
wcscpy_s(f.lfFaceName, L"微软雅黑");
settextstyle(&f);
```

### 优化效果

| 指标       | 优化前           | 优化后       |
| ---------- | ---------------- | ------------ |
| 画面清晰度 | 125% 缩放时模糊  | 1:1 像素清晰 |
| 文字边缘   | 明显锯齿         | 平滑抗锯齿   |
| 用户体验   | 看起来像低分辨率 | 高清显示     |

---

## 4. 多人模式的 AI 对手、倒计时和 Spawn 方向问题

### 问题描述

**1. 人机对战未实现 AI 对手**  
菜单中有"人机对战"选项，但 `InitPVEMode()` 只调用了 `InitSingleMode()`，没有创建 AI 控制的蛇。

**2. 多人模式缺少倒计时**  
双人/人机模式开始时立即进入游戏，玩家没有准备时间，容易开局就失误。

**3. 双人 Spawn 方向错误**  
初始配置为左侧蛇朝左、右侧蛇朝右（面对面），导致开局可能相撞，应该改为背对背。

### 解决方案

**1. 实现 PVE 模式的 AI 对手**

```cpp
void GameManager::InitPVEMode() {
    renderer = new Renderer();
    renderer->Init(totalWidth, totalHeight, L"贪吃蛇 - 人机对战", false);

    gameMap = new GameMap();

    // 创建玩家蛇（键盘控制）
    Point startPos1(MAP_WIDTH / 3, MAP_HEIGHT / 2);
    Snake *snake1 = new Snake(0, startPos1, RIGHT, RGB(0, 255, 0));
    snake1->SetController(new KeyboardController(0));
    snakes.push_back(snake1);
    playerSnake = snake1;

    // 创建 AI 蛇
    Point startPos2(MAP_WIDTH * 2 / 3, MAP_HEIGHT / 2);
    Snake *snake2 = new Snake(1, startPos2, LEFT, RGB(255, 0, 255));
    snake2->SetController(new AIController());  // 使用 AI 控制器
    snakes.push_back(snake2);

    foodManager = new FoodManager();
    foodManager->SpawnFood(*playerSnake, *gameMap);
}
```

**2. 修复双人 Spawn 方向为背对背**

```cpp
void GameManager::InitLocalPVPMode() {
    // 左侧蛇朝右（背离左边界）
    Point startPos1(MAP_WIDTH / 3, MAP_HEIGHT / 2);
    Snake *snake1 = new Snake(0, startPos1, RIGHT, RGB(0, 255, 0));

    // 右侧蛇朝左（背离右边界）
    Point startPos2(MAP_WIDTH * 2 / 3, MAP_HEIGHT / 2);
    Snake *snake2 = new Snake(1, startPos2, LEFT, RGB(255, 255, 0));
}
```

**3. 添加倒计时显示（叠加在游戏界面上）**

```cpp
void GameManager::Run() {
    // 多人模式显示倒计时
    if (currentMode == LOCAL_PVP || currentMode == NET_PVP || currentMode == PVE) {
        // 先渲染游戏界面作为背景
        Render();

        // 倒计时 3...2...1
        for (int i = 3; i > 0; i--) {
            BeginBatchDraw();
            Render();  // 重绘游戏界面

            // 绘制半透明遮罩
            setfillcolor(RGB(0, 0, 0));
            solidrectangle(0, 0, getwidth(), getheight());

            // 显示倒计时数字
            settextcolor(WHITE);
            settextstyle(120, 0, L"微软雅黑");
            wchar_t countdownText[10];
            swprintf_s(countdownText, L"%d", i);
            outtextxy(centerX, centerY, countdownText);

            EndBatchDraw();
            Sleep(1000);
        }

        // 显示"开始!"
        // ...类似逻辑
    }
}
```

### 优化效果

| 指标           | 优化前               | 优化后                     |
| -------------- | -------------------- | -------------------------- |
| 人机对战       | 只有一条玩家蛇       | 玩家蛇 + AI 蛇             |
| 多人准备时间   | 无倒计时立即开始     | 3 秒倒计时 + 游戏界面预览  |
| 双人 Spawn     | 面对面容易相撞       | 背对背更合理               |
| 倒计时显示方式 | cleardevice 黑屏显示 | 叠加在游戏界面上，体验更好 |

---

## 7. UI 重构：莫兰迪配色与交互优化

### 设计目标

从初始的浅蓝色风格演变为完整的**莫兰迪极简风格**，提升视觉层次感和交互体验。

### 最终配色方案

| 颜色名称 | 十六进制  | RGB             | 用途                             |
| -------- | --------- | --------------- | -------------------------------- |
| 米白色   | `#F9F7F7` | (249, 247, 247) | 背景色                           |
| 灰蓝色   | `#DBE2EF` | (219, 226, 239) | 次级元素（按钮默认态、墙体）     |
| 主蓝色   | `#3F72AF` | (63, 114, 175)  | 主要元素（P1 蛇、标签文字）      |
| 深蓝色   | `#112D4E` | (17, 45, 78)    | 强调元素（数值文字、标题）       |
| 莫兰迪粉 | `#E08585` | (224, 133, 133) | P2 蛇身（双人模式对比色）        |
| 亮蓝色   | `#5584BC` | (85, 132, 188)  | 按钮悬停态（计算：3F72AF + 30%） |

### 核心改进

#### 1. 按钮交互系统

**胶囊按钮实现（拼图法）**

```cpp
void DrawCapsuleButton(int x, int y, int w, int h, COLORREF color) {
    int radius = h / 2;
    solidcircle(x + radius, y + radius, radius);           // 左半圆
    solidcircle(x + w - radius, y + radius, radius);       // 右半圆
    solidrectangle(x + radius, y, x + w - radius, y + h);  // 中间矩形
}
```

**统一悬停逻辑**

- **默认态：** 灰蓝色按钮 (#DBE2EF) + 深蓝色文字 (#112D4E)
- **悬停态：** 亮蓝色按钮 (#5584BC) + 白色文字
- **间距优化：** 按钮垂直间距从 140px 增加到 160px
- **字体统一：** 所有按钮使用 48px 粗体微软雅黑

#### 2. 墙体渲染优化

**从碎片化到统一边框**

```cpp
// ❌ 旧方案：循环绘制单个方块
for (int y = 0; y < MAP_HEIGHT; y++) {
    for (int x = 0; x < MAP_WIDTH; x++) {
        if (是边界) DrawBlock(x, y, wallColor);
    }
}

// ✅ 新方案：4 条矩形边框
void DrawMap() {
    COLORREF wallColor = RGB(219, 226, 239);  // #DBE2EF
    solidrectangle(0, 0, mapWidth, BLOCK_SIZE);              // 上
    solidrectangle(0, 0, BLOCK_SIZE, mapHeight);             // 左
    solidrectangle(0, mapHeight - BLOCK_SIZE, mapWidth, mapHeight); // 下
    solidrectangle(mapWidth - BLOCK_SIZE, 0, mapWidth, mapHeight);  // 右
}
```

**优化效果：**

- 渲染从 O(n) 降到 O(1)
- 视觉更整体统一

#### 3. 侧边栏 UI 重构

**布局设计**

```
┌─────────────────┐
│ 分隔线 (3px 灰蓝)│
├─────────────────┤
│ P1 ●            │ ← 圆形标记（solidcircle）
│ 得分: 100       │ ← 左对齐，标签 24px / 数值 40px 粗体
│ 时长: 02:30     │
│                 │
│ P2 ●            │
│ 得分: 85        │
│ 时长: 02:30     │
├─────────────────┤
│ [  退出游戏  ]  │ ← 空心胶囊按钮，宽度 70% 侧边栏
└─────────────────┘
```

**实现细节**

```cpp
void DrawUI() {
    int dividerX = mapWidth + 18;
    setfillcolor(RGB(219, 226, 239));  // #DBE2EF
    solidrectangle(dividerX, 0, dividerX + 3, windowHeight);  // 分隔线

    // 玩家标记（圆形代替方块）
    int markerX = mapWidth + 50;
    solidcircle(markerX, y, 12);  // 半径 12px

    // 标签文字（#3F72AF, 24px 常规）
    settextcolor(RGB(63, 114, 175));
    settextstyle(24, 0, L"微软雅黑");
    outtextxy(x, y, L"得分:");

    // 数值文字（#112D4E, 40px 粗体）
    settextcolor(RGB(17, 45, 78));
    settextstyle(40, 0, L"微软雅黑", 0, 0, FW_BOLD, false, false, false);
    outtextxy(x + offset, y, scoreText);
}
```

#### 4. 多人模式增强

**双人计分系统**

```cpp
class GameManager {
    int player1Score, player2Score;  // 分别记录双方得分
    int player1Time, player2Time;    // 分别记录游戏时长

    void InitLocalPVPMode() {
        player1Score = player2Score = 0;
        player1Time = player2Time = 0;
    }

    void ShowGameOver() {
        renderer->DrawMultiplayerGameOverScreen(
            playerWon,    // P1 是否胜利
            player1Score, player2Score,  // 双方得分
            player1Time,  player2Time    // 双方时长
        );
    }
};
```

**游戏结束界面**

- 显示胜负标题（"🏆 胜利！" / "战败"）
- 并排展示双方数据对比
- 保持配色一致性

#### 5. 蛇身颜色方案

| 模式     | P1 颜色         | P2 颜色             |
| -------- | --------------- | ------------------- |
| 单人模式 | #3F72AF（主蓝） | -                   |
| 双人模式 | #3F72AF（主蓝） | #E08585（莫兰迪粉） |
| 人机对战 | #3F72AF（主蓝） | #E08585（莫兰迪粉） |

### 技术难点与解决方案

#### 问题 1：EasyX 无原生胶囊按钮

**解决方案：** 拼图法组合绘制

- 左右两个 `solidcircle`（半径 = 高度 / 2）
- 中间 `solidrectangle` 补齐
- 关键：`setlinecolor` 与 `setfillcolor` 相同以消除黑边

#### 问题 2：函数签名不兼容导致编译错误

**场景：** 测试环境修改后同步到生产环境时报错

```
错误 E0147: 声明与 "void Renderer::DrawMultiplayerGameOverScreen(bool, int)" 不兼容
```

**根本原因：** 代码不同步

- 旧版本：`DrawMultiplayerGameOverScreen(bool playerWon, int finalScore)`
- 新版本：`DrawMultiplayerGameOverScreen(bool playerWon, int p1Score, int p2Score, int p1Time, int p2Time)`

**解决流程：**

1. 更新 Renderer.h 声明（5 参数版本）
2. 更新 Renderer.cpp 实现
3. 更新 GameManager.cpp 调用处
4. 添加 GameManager.h 中的新成员变量
5. 在所有初始化函数中初始化这些变量

#### 问题 3：InitNetworkPVPMode 链接错误

**错误信息：**

```
错误 LNK2019: 无法解析的外部符号 "void GameManager::InitNetworkPVPMode(void)"
```

**原因分析：**

- GameManager.h 中声明了函数
- InitByGameMode() 中调用了该函数
- 但 GameManager.cpp 中没有实现

**解决方案：** 添加占位实现

```cpp
void GameManager::InitNetworkPVPMode() {
    // 网络对战模式（暂时未实现，使用本地双人逻辑）
    InitLocalPVPMode();
}
```

### 设计原则总结

1. **配色克制：** 4 色系统（背景、次级、主要、强调）+ 1 个对比色
2. **交互一致：** 所有按钮统一悬停逻辑和视觉反馈
3. **层次分明：** 字重（常规/粗体）、字号（24/40/48/64）建立视觉层级
4. **性能优先：** 墙体从循环绘制改为整体边框（O(n) → O(1)）
5. **信息对称：** 双人模式数据并排展示，空间分配均衡

### 优化效果

| 指标       | 优化前              | 优化后                       |
| ---------- | ------------------- | ---------------------------- |
| 配色方案   | 单一浅蓝色          | 莫兰迪 5 色系统              |
| 按钮交互   | 静态矩形            | 胶囊形 + 悬停高亮            |
| 墙体渲染   | 循环绘制方块        | 统一边框（性能提升 ~100 倍） |
| 侧边栏布局 | 方块标记 + 居中文字 | 圆形标记 + 左对齐 + 分隔线   |
| 双人计分   | 仅显示单人分数      | 双方得分/时长完整记录        |
| 视觉一致性 | 各场景风格不统一    | 全局统一配色和字体规范       |

---

## 8. 历史记录查询功能的实现

### 问题描述

需要添加游戏历史记录查看功能，让玩家可以回顾过往战绩，支持按模式筛选、分页浏览，并展示历史最高分。

### 关键问题

**1. 文件编码与中文乱码**

最初使用中文字段存储游戏记录，导致文件读取时出现编码问题（GBK/UTF-8 冲突），CSV 解析失败。

**2. UI 列对齐问题**

表头与内容列位置不一致，例如表头"模式"在 `x+300`，但实际模式标签在 `x+15-85` 范围，导致视觉混乱。

**3. 底部按钮遮挡**

显示 7 条记录时，最后一条会被底部的"返回主菜单"按钮遮挡。

### 解决方案

**1. 数据格式重构**

采用纯英文 CSV 格式存储，避免编码问题：

```csv
2025-12-07 13:13:22,LOCAL_PVP,30,5
时间,模式,分数,蛇长
```

使用模式映射函数转换显示：

```cpp
std::wstring ParseModeFromEnglish(const std::string& mode) {
    if (mode == "SINGLE" || mode == "BEGINNER" || ...) return L"单人";
    if (mode == "LOCAL_PVP" || mode == "NET_PVP") return L"双人";
    return L"未知";
}
```

**2. 严格列对齐**

定义统一的列坐标系统：

```cpp
int modeX = listX + 15;      // 模式标签起始
int timeX = listX + 110;     // 时间起始
int lengthX = listX + 500;   // 长度起始
int scoreX = listX + listWidth - 30;  // 得分右对齐

// 表头使用相同坐标
outtextxy(timeX, headerY, L"时间");
outtextxy(modeX + 20, headerY, L"模式");
```

**3. UI 优化**

- 减少每页显示数量：`MAX_DISPLAY_RECORDS = 5`
- 添加固定白色底栏（footerY=900, height=180）
- 实现翻页功能："上一页"/"下一页"按钮 + 页码显示
- 胶囊式筛选按钮：统一背景 + 滑动选中块

**4. 文件读取容错**

尝试多个路径查找 `game_records.txt`：

```cpp
std::vector<std::string> paths = {
    "game_records.txt",
    "..\\..\\game_records.txt",
    "..\\game_records.txt"
};
```

### 实现效果

- ✅ 自动保存每局游戏记录
- ✅ 支持按"全部/单人/双人"筛选
- ✅ 分页浏览（每页 5 条，显示页码）
- ✅ 历史最高分卡片展示
- ✅ 胶囊式筛选按钮交互
- ✅ 完美列对齐，无遮挡问题

---

## 7. 代码重构：Windows API 命名冲突问题

### 问题描述

在创建通用 UI 组件系统（`UIComponent.h/cpp`）进行代码重构时，遇到多个编译错误：

```
C2365: "LEFT": 重定义；以前的定义是"枚举数"
C2365: "RECT": 重定义；以前的定义是"typedef"
C2275: "RECT": 应为表达式而不是类型
C2046: 非法的 case (在 switch 语句中)
C2660: "InputManager::GetMousePosition": 函数不接受 1 个参数
```

### 问题原因

**1. Windows API 命名冲突**

```cpp
// UIComponent.h 中定义的枚举
enum ButtonStyle { CAPSULE, ROUNDED_RECT, RECT };  // ❌ RECT与Windows冲突
enum TextAlign { LEFT, CENTER, RIGHT };  // ❌ LEFT/RIGHT与Windows宏冲突
```

- `RECT` 是 Windows.h 中定义的结构体类型
- `LEFT` 和 `RIGHT` 是 Windows 预定义宏
- 导致重定义错误和 switch 语句语法错误

**2. 不存在的方法调用**

```cpp
// MenuScene.cpp 中错误调用
MOUSEMSG msg;
if (inputMgr.GetMousePosition(msg)) {  // ❌ 该方法不存在
    buttons[i]->UpdateState(msg.x, msg.y, false);
}
```

`InputManager` 类中没有 `GetMousePosition()` 方法。

### 解决方案

**1. 为枚举值添加明确前缀**

```cpp
// 修改后的枚举定义
enum ButtonStyle {
    BUTTON_CAPSULE,       // 胶囊形
    BUTTON_ROUNDED_RECT,  // 圆角矩形
    BUTTON_RECT           // 直角矩形
};

enum TextAlign {
    TEXT_ALIGN_LEFT,
    TEXT_ALIGN_CENTER,
    TEXT_ALIGN_RIGHT
};
```

**2. 更新所有使用枚举的代码**

```cpp
// UIComponent.cpp - switch 语句
switch (style) {
    case BUTTON_CAPSULE: DrawCapsule(bgColor, txtColor); break;
    case BUTTON_ROUNDED_RECT: DrawRoundedRect(bgColor, txtColor); break;
    case BUTTON_RECT: DrawRect(bgColor, txtColor); break;
}

// MenuScene.cpp - 按钮创建
auto btn = std::make_unique<UIButton>(x, y, width, height, text, BUTTON_CAPSULE);
```

**3. 简化按钮状态更新逻辑**

```cpp
// 移除不存在的方法调用，直接模拟悬停状态
if (i == selectedOption) {
    buttons[i]->UpdateState(buttons[i]->GetX() + 1, buttons[i]->GetY() + 1, false);
} else {
    buttons[i]->UpdateState(-1, -1, false);
}
```

### 重构成果

通过引入 `UIComponent` 系统，成功重构了 `MenuScene`：

**代码对比**：

```cpp
// 重构前 - 每个按钮约 30 行
MenuItem item;
item.text = L"单人游戏";
item.x = startX; item.y = startY;
item.width = 600; item.height = 100;
// + 15 行手动绘制胶囊按钮代码
// + 自定义 IsMouseOver 检测

// 重构后 - 每个按钮约 5 行
MenuItem item;
item.text = L"单人游戏";
auto btn = std::make_unique<UIButton>(x, y, 600, 100, text, BUTTON_CAPSULE);
btn->SetColors(normalColor, hoverColor);
btn->Draw();  // 一行完成绘制
```

**效果**：

- ✅ MenuScene.cpp 减少约 100 行代码（~19%）
- ✅ 按钮创建效率提升 75%
- ✅ 消除重复的 IsMouseOver 方法
- ✅ 统一应用莫兰迪配色方案

### 经验总结

1. **避免使用 Windows 系统保留字**：`RECT`、`LEFT`、`RIGHT`、`POINT` 等都是常见冲突源
2. **使用明确的命名前缀**：为枚举值添加 `BUTTON_`、`TEXT_ALIGN_` 等前缀避免冲突
3. **调用前验证方法存在性**：避免假设性编程，确保调用的方法已定义
4. **渐进式重构**：先创建新组件系统，验证无误后再逐步替换旧代码

---

_最后更新：2025 年 12 月 7 日_
